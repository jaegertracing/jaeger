syntax = "proto3";

package jaeger.storage.v2;

import "gogoproto/gogo.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "opentelemetry/proto/trace/v1/trace.proto";

option go_package = "storage";

// GetTraceParams represents the query for a single trace from the storage backend.
message GetTraceParams {
  // trace_id is a 16 byte array containing the unique identifier for the trace to query.
  bytes trace_id = 1;

  // start_time is the start of the time interval to search for the trace_id.
  //
  // This field is optional.
  google.protobuf.Timestamp start_time = 2 [(gogoproto.stdtime) = true];

  // end_time is the end of the time interval to search for the trace_id.
  //
  // This field is optional.
  google.protobuf.Timestamp end_time = 3 [(gogoproto.stdtime) = true];
}

// GetTracesRequest represents a request to retrieve multiple traces.
message GetTracesRequest {
  repeated GetTraceParams query = 1;
}

// GetServicesRequest represents a request to get service names.
message GetServicesRequest {}

// GetServicesResponse represents the response for GetServicesRequest.
message GetServicesResponse {
  repeated string services = 1;
}

// GetOperationsRequest represents a request to get operation names.
message GetOperationsRequest {
  // service is the name of the service for which to get operation names.
  //
  // This field is required.
  string service = 1;

  // span_kind is the type of span which is used to distinguish between
  // spans generated in a particular context.
  //
  // This field is optional.
  opentelemetry.proto.trace.v1.Span.SpanKind span_kind = 2;
}

// Operation contains information about an operation for a given service.
message Operation {
  string name = 1;
  opentelemetry.proto.trace.v1.Span.SpanKind span_kind = 2;
}

// GetOperationsResponse represents the response for GetOperationsRequest.
message GetOperationsResponse {
  repeated Operation operations = 1;
}

message TraceQueryParams {
  // service_name is a filter for traces that have been generated by a specific service.
  string service_name = 1;
  // operation_name is a filter for traces that have been generated by a specific operation.
  string operation_name = 2;
  // attributes contains a map of key-value pairs where the key is the name of the attribute
  // and the value is the string-representation of the attribute value.
  // Attributes are matched against the attributes of the resources and spans.
  // At least one span in a trace must match all specified attributes.
  map<string, string> attributes = 3;
  // start_time is the start of the time interval for the query. All the returned traces
  // will contain spans that have started after this time.
  google.protobuf.Timestamp start_time = 4 [
    (gogoproto.stdtime) = true,
    (gogoproto.nullable) = false
  ];
  // end_time is the end of the time interval for the query. All the returned traces
  // will contain spans that have started before this time.
  google.protobuf.Timestamp end_time = 5 [
    (gogoproto.stdtime) = true,
    (gogoproto.nullable) = false
  ];
  // min_duration is the minimum duration of the trace in nanoseconds. All the returned traces
  // will have spans that lasted alteast this long.
  google.protobuf.Duration min_duration = 6 [
    (gogoproto.stdduration) = true,
    (gogoproto.nullable) = false
  ];
  // max_duration is the maximum duration of the trace in nanoseconds. All the returned traces
  // will have spans that lasted at most this long.
  google.protobuf.Duration max_duration = 7 [
    (gogoproto.stdduration) = true,
    (gogoproto.nullable) = false
  ];
  // max_traces is the maximum number of traces to return. If the number of traces
  // matching the query is greater than this number, only the first max_traces
  // traces will be returned.
  int max_traces = 8;
}

service TraceReader {
  // GetTraces returns a stream that retrieves all traces with given IDs.
  //
  // Chunking requirements:
  // - A single TracesData chunk MUST NOT contain spans from multiple traces.
  // - Large traces MAY be split across multiple, *consecutive* TracesData chunks.
  // - Each returned TracesData object MUST NOT be empty.
  //
  // Edge cases:
  // - If no spans are found for any given trace ID, the ID is ignored.
  // - If none of the trace IDs are found in the storage, an empty response is returned.
  // - If an error is encountered, the stream returns the error and stops.
  rpc GetTraces(GetTracesRequest) returns (stream opentelemetry.proto.trace.v1.TracesData) {}

  // GetServices returns all service names known to the backend from traces
  // within its retention period.
  rpc GetServices(GetServicesRequest) returns (GetServicesResponse) {}

  // GetOperations returns all operation names for a given service
  // known to the backend from traces within its retention period.
  rpc GetOperations(GetOperationsRequest) returns (GetOperationsResponse) {}

  // FindTraces returns a stream that retrieves traces matching query parameters.
  //
  // The chunking rules are the same as for GetTraces.
  //
  // If no matching traces are found, an empty stream is returned.
  // If an error is encountered, the iterator returns the error and stops.
  //
  // There's currently an implementation-dependent ambiguity whether all query filters
  // (such as multiple tags) must apply to the same span within a trace, or can be satisfied
  // by different spans.
  rpc FindTraces(TraceQueryParams) returns (stream opentelemetry.proto.trace.v1.TracesData) {}

  // FindTraceIDs returns a stream that retrieves IDs of traces matching query parameters.
  //
  // If no matching traces are found, an empty stream is returned.
  // If an error is encountered, the stream returns the error and stops.
  //
  // This call behaves identically to FindTraces, except that it returns only the list
  // of matching trace IDs. This is useful in some contexts, such as batch jobs, where a
  // large list of trace IDs may be queried first and then the full traces are loaded
  // in batches.
  rpc FindTraceIDs(TraceQueryParams) returns (stream bytes) {}
}
