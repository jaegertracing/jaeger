// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: traces_storage.proto

package storage

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	v1 "go.opentelemetry.io/proto/otlp/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GetTraceRequest represents the query for a single trace from the storage backend.
type GetTraceRequest struct {
	// trace_id is a 16 byte array containing the unique identifier for the trace to query.
	TraceId []byte `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	// start_time is the start of the time interval to search for the trace_id.
	//
	// This field is optional.
	StartTime *time.Time `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	// end_time is the end of the time interval to search for the trace_id.
	//
	// This field is optional.
	EndTime              *time.Time `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetTraceRequest) Reset()         { *m = GetTraceRequest{} }
func (m *GetTraceRequest) String() string { return proto.CompactTextString(m) }
func (*GetTraceRequest) ProtoMessage()    {}
func (*GetTraceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeafc47c70a2d5ec, []int{0}
}
func (m *GetTraceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTraceRequest.Unmarshal(m, b)
}
func (m *GetTraceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTraceRequest.Marshal(b, m, deterministic)
}
func (m *GetTraceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTraceRequest.Merge(m, src)
}
func (m *GetTraceRequest) XXX_Size() int {
	return xxx_messageInfo_GetTraceRequest.Size(m)
}
func (m *GetTraceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTraceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTraceRequest proto.InternalMessageInfo

func (m *GetTraceRequest) GetTraceId() []byte {
	if m != nil {
		return m.TraceId
	}
	return nil
}

func (m *GetTraceRequest) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *GetTraceRequest) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// GetTracesRequest represents a request to retrieve multiple traces.
type GetTracesRequest struct {
	TraceRequests        []*GetTraceRequest `protobuf:"bytes,1,rep,name=trace_requests,json=traceRequests,proto3" json:"trace_requests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetTracesRequest) Reset()         { *m = GetTracesRequest{} }
func (m *GetTracesRequest) String() string { return proto.CompactTextString(m) }
func (*GetTracesRequest) ProtoMessage()    {}
func (*GetTracesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_eeafc47c70a2d5ec, []int{1}
}
func (m *GetTracesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTracesRequest.Unmarshal(m, b)
}
func (m *GetTracesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTracesRequest.Marshal(b, m, deterministic)
}
func (m *GetTracesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTracesRequest.Merge(m, src)
}
func (m *GetTracesRequest) XXX_Size() int {
	return xxx_messageInfo_GetTracesRequest.Size(m)
}
func (m *GetTracesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTracesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTracesRequest proto.InternalMessageInfo

func (m *GetTracesRequest) GetTraceRequests() []*GetTraceRequest {
	if m != nil {
		return m.TraceRequests
	}
	return nil
}

func init() {
	proto.RegisterType((*GetTraceRequest)(nil), "jaeger.storage.v2.GetTraceRequest")
	proto.RegisterType((*GetTracesRequest)(nil), "jaeger.storage.v2.GetTracesRequest")
}

func init() { proto.RegisterFile("traces_storage.proto", fileDescriptor_eeafc47c70a2d5ec) }

var fileDescriptor_eeafc47c70a2d5ec = []byte{
	// 306 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x90, 0xbd, 0x4e, 0xc3, 0x30,
	0x10, 0xc7, 0x31, 0x45, 0xb4, 0x75, 0xf9, 0xb4, 0x3a, 0x84, 0x2c, 0x8d, 0x32, 0x65, 0x72, 0x68,
	0x18, 0x19, 0x90, 0x2a, 0x24, 0xd4, 0x35, 0xea, 0x84, 0x54, 0x45, 0x2e, 0x39, 0xac, 0xa2, 0x24,
	0x0e, 0xf6, 0x35, 0x12, 0x6f, 0xc1, 0x73, 0xf0, 0x52, 0xbc, 0x0a, 0x8a, 0x9d, 0x20, 0x3e, 0x96,
	0x6e, 0x77, 0xff, 0xfb, 0xdf, 0xdd, 0xef, 0x8e, 0x4e, 0x51, 0x8b, 0x27, 0x30, 0x99, 0x41, 0xa5,
	0x85, 0x04, 0x5e, 0x6b, 0x85, 0x8a, 0x5d, 0xbe, 0x08, 0x90, 0xa0, 0x79, 0xaf, 0x36, 0x89, 0x3f,
	0x95, 0x4a, 0x2a, 0x5b, 0x8d, 0xdb, 0xc8, 0x19, 0xfd, 0x99, 0x54, 0x4a, 0x16, 0x10, 0xdb, 0x6c,
	0xb3, 0x7b, 0x8e, 0x71, 0x5b, 0x82, 0x41, 0x51, 0xd6, 0x9d, 0x21, 0x52, 0x35, 0x54, 0x08, 0x05,
	0x94, 0x80, 0xfa, 0xcd, 0xf9, 0x62, 0xbb, 0x33, 0x6e, 0xe6, 0x2e, 0x70, 0xce, 0xf0, 0x83, 0xd0,
	0xf3, 0x07, 0xc0, 0x55, 0x2b, 0xa5, 0xf0, 0xba, 0x03, 0x83, 0xec, 0x8a, 0x8e, 0xac, 0x25, 0xdb,
	0xe6, 0x1e, 0x09, 0x48, 0x74, 0x92, 0x0e, 0x6d, 0xbe, 0xcc, 0xd9, 0x1d, 0xa5, 0x06, 0x85, 0xc6,
	0xac, 0xdd, 0xe8, 0x1d, 0x06, 0x24, 0x9a, 0x24, 0x3e, 0x77, 0x38, 0xbc, 0xc7, 0xe1, 0xab, 0x1e,
	0x67, 0x71, 0xf4, 0xfe, 0x39, 0x23, 0xe9, 0xd8, 0xf6, 0xb4, 0x2a, 0xbb, 0xa5, 0x23, 0xa8, 0x72,
	0xd7, 0x3e, 0xd8, 0xb3, 0x7d, 0x08, 0x55, 0xde, 0x6a, 0xe1, 0x9a, 0x5e, 0xf4, 0xac, 0xa6, 0x87,
	0x5d, 0xd2, 0x33, 0x07, 0xab, 0x9d, 0x60, 0x3c, 0x12, 0x0c, 0xa2, 0x49, 0x12, 0xf2, 0x7f, 0xdf,
	0xe4, 0x7f, 0x0e, 0x4d, 0x4f, 0xf1, 0x47, 0x66, 0x92, 0x82, 0x4e, 0xba, 0xb2, 0xc8, 0x41, 0xb3,
	0x35, 0x1d, 0x7f, 0x6f, 0x63, 0x7b, 0x8c, 0xf3, 0x23, 0xfe, 0xeb, 0xed, 0xee, 0x20, 0xee, 0xbe,
	0xdd, 0xcc, 0xb9, 0x9b, 0x74, 0x2f, 0x50, 0x84, 0x07, 0xd7, 0x64, 0x31, 0x7e, 0x1c, 0x76, 0xb3,
	0x36, 0xc7, 0xd6, 0x79, 0xf3, 0x15, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xa7, 0x07, 0x11, 0x17, 0x02,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TraceReaderClient is the client API for TraceReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TraceReaderClient interface {
	// GetTraces returns a stream that retrieves all traces with given IDs.
	//
	// Chunking requirements:
	// - A single TracesData chunk MUST NOT contain spans from multiple traces.
	// - Large traces MAY be split across multiple, *consecutive* TracesData chunks.
	// - Each returned TracesData object MUST NOT be empty.
	//
	// Edge cases:
	// - If no spans are found for any given trace ID, the ID is ignored.
	// - If none of the trace IDs are found in the storage, an empty response is returned.
	// - If an error is encountered, the iterator returns the error and stops.
	GetTraces(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (TraceReader_GetTracesClient, error)
}

type traceReaderClient struct {
	cc *grpc.ClientConn
}

func NewTraceReaderClient(cc *grpc.ClientConn) TraceReaderClient {
	return &traceReaderClient{cc}
}

func (c *traceReaderClient) GetTraces(ctx context.Context, in *GetTraceRequest, opts ...grpc.CallOption) (TraceReader_GetTracesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TraceReader_serviceDesc.Streams[0], "/jaeger.storage.v2.TraceReader/GetTraces", opts...)
	if err != nil {
		return nil, err
	}
	x := &traceReaderGetTracesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TraceReader_GetTracesClient interface {
	Recv() (*v1.TracesData, error)
	grpc.ClientStream
}

type traceReaderGetTracesClient struct {
	grpc.ClientStream
}

func (x *traceReaderGetTracesClient) Recv() (*v1.TracesData, error) {
	m := new(v1.TracesData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TraceReaderServer is the server API for TraceReader service.
type TraceReaderServer interface {
	// GetTraces returns a stream that retrieves all traces with given IDs.
	//
	// Chunking requirements:
	// - A single TracesData chunk MUST NOT contain spans from multiple traces.
	// - Large traces MAY be split across multiple, *consecutive* TracesData chunks.
	// - Each returned TracesData object MUST NOT be empty.
	//
	// Edge cases:
	// - If no spans are found for any given trace ID, the ID is ignored.
	// - If none of the trace IDs are found in the storage, an empty response is returned.
	// - If an error is encountered, the iterator returns the error and stops.
	GetTraces(*GetTraceRequest, TraceReader_GetTracesServer) error
}

// UnimplementedTraceReaderServer can be embedded to have forward compatible implementations.
type UnimplementedTraceReaderServer struct {
}

func (*UnimplementedTraceReaderServer) GetTraces(req *GetTraceRequest, srv TraceReader_GetTracesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTraces not implemented")
}

func RegisterTraceReaderServer(s *grpc.Server, srv TraceReaderServer) {
	s.RegisterService(&_TraceReader_serviceDesc, srv)
}

func _TraceReader_GetTraces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTraceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TraceReaderServer).GetTraces(m, &traceReaderGetTracesServer{stream})
}

type TraceReader_GetTracesServer interface {
	Send(*v1.TracesData) error
	grpc.ServerStream
}

type traceReaderGetTracesServer struct {
	grpc.ServerStream
}

func (x *traceReaderGetTracesServer) Send(m *v1.TracesData) error {
	return x.ServerStream.SendMsg(m)
}

var _TraceReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.storage.v2.TraceReader",
	HandlerType: (*TraceReaderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTraces",
			Handler:       _TraceReader_GetTraces_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "traces_storage.proto",
}
