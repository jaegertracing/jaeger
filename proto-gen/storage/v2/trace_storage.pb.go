// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: trace_storage.proto

package storage

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	v11 "go.opentelemetry.io/proto/otlp/collector/trace/v1"
	v1 "go.opentelemetry.io/proto/otlp/trace/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GetTraceParams represents the query for a single trace from the storage backend.
type GetTraceParams struct {
	// trace_id is a 16 byte array containing the unique identifier for the trace to query.
	TraceId []byte `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	// start_time is the start of the time interval to search for the trace_id.
	//
	// This field is optional.
	StartTime *time.Time `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty"`
	// end_time is the end of the time interval to search for the trace_id.
	//
	// This field is optional.
	EndTime              *time.Time `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetTraceParams) Reset()         { *m = GetTraceParams{} }
func (m *GetTraceParams) String() string { return proto.CompactTextString(m) }
func (*GetTraceParams) ProtoMessage()    {}
func (*GetTraceParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{0}
}
func (m *GetTraceParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTraceParams.Unmarshal(m, b)
}
func (m *GetTraceParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTraceParams.Marshal(b, m, deterministic)
}
func (m *GetTraceParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTraceParams.Merge(m, src)
}
func (m *GetTraceParams) XXX_Size() int {
	return xxx_messageInfo_GetTraceParams.Size(m)
}
func (m *GetTraceParams) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTraceParams.DiscardUnknown(m)
}

var xxx_messageInfo_GetTraceParams proto.InternalMessageInfo

func (m *GetTraceParams) GetTraceId() []byte {
	if m != nil {
		return m.TraceId
	}
	return nil
}

func (m *GetTraceParams) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *GetTraceParams) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

// GetTracesRequest represents a request to retrieve multiple traces.
type GetTracesRequest struct {
	Query                []*GetTraceParams `protobuf:"bytes,1,rep,name=query,proto3" json:"query,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetTracesRequest) Reset()         { *m = GetTracesRequest{} }
func (m *GetTracesRequest) String() string { return proto.CompactTextString(m) }
func (*GetTracesRequest) ProtoMessage()    {}
func (*GetTracesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{1}
}
func (m *GetTracesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetTracesRequest.Unmarshal(m, b)
}
func (m *GetTracesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetTracesRequest.Marshal(b, m, deterministic)
}
func (m *GetTracesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTracesRequest.Merge(m, src)
}
func (m *GetTracesRequest) XXX_Size() int {
	return xxx_messageInfo_GetTracesRequest.Size(m)
}
func (m *GetTracesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTracesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTracesRequest proto.InternalMessageInfo

func (m *GetTracesRequest) GetQuery() []*GetTraceParams {
	if m != nil {
		return m.Query
	}
	return nil
}

// GetServicesRequest represents a request to get service names.
type GetServicesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetServicesRequest) Reset()         { *m = GetServicesRequest{} }
func (m *GetServicesRequest) String() string { return proto.CompactTextString(m) }
func (*GetServicesRequest) ProtoMessage()    {}
func (*GetServicesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{2}
}
func (m *GetServicesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetServicesRequest.Unmarshal(m, b)
}
func (m *GetServicesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetServicesRequest.Marshal(b, m, deterministic)
}
func (m *GetServicesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServicesRequest.Merge(m, src)
}
func (m *GetServicesRequest) XXX_Size() int {
	return xxx_messageInfo_GetServicesRequest.Size(m)
}
func (m *GetServicesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServicesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetServicesRequest proto.InternalMessageInfo

// GetServicesResponse represents the response for GetServicesRequest.
type GetServicesResponse struct {
	Services             []string `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetServicesResponse) Reset()         { *m = GetServicesResponse{} }
func (m *GetServicesResponse) String() string { return proto.CompactTextString(m) }
func (*GetServicesResponse) ProtoMessage()    {}
func (*GetServicesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{3}
}
func (m *GetServicesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetServicesResponse.Unmarshal(m, b)
}
func (m *GetServicesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetServicesResponse.Marshal(b, m, deterministic)
}
func (m *GetServicesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetServicesResponse.Merge(m, src)
}
func (m *GetServicesResponse) XXX_Size() int {
	return xxx_messageInfo_GetServicesResponse.Size(m)
}
func (m *GetServicesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetServicesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetServicesResponse proto.InternalMessageInfo

func (m *GetServicesResponse) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

// GetOperationsRequest represents a request to get operation names.
type GetOperationsRequest struct {
	// service is the name of the service for which to get operation names.
	//
	// This field is required.
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	// span_kind is the type of span which is used to distinguish between
	// spans generated in a particular context.
	//
	// This field is optional.
	SpanKind             v1.Span_SpanKind `protobuf:"varint,2,opt,name=span_kind,json=spanKind,proto3,enum=opentelemetry.proto.trace.v1.Span_SpanKind" json:"span_kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GetOperationsRequest) Reset()         { *m = GetOperationsRequest{} }
func (m *GetOperationsRequest) String() string { return proto.CompactTextString(m) }
func (*GetOperationsRequest) ProtoMessage()    {}
func (*GetOperationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{4}
}
func (m *GetOperationsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetOperationsRequest.Unmarshal(m, b)
}
func (m *GetOperationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetOperationsRequest.Marshal(b, m, deterministic)
}
func (m *GetOperationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperationsRequest.Merge(m, src)
}
func (m *GetOperationsRequest) XXX_Size() int {
	return xxx_messageInfo_GetOperationsRequest.Size(m)
}
func (m *GetOperationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperationsRequest proto.InternalMessageInfo

func (m *GetOperationsRequest) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *GetOperationsRequest) GetSpanKind() v1.Span_SpanKind {
	if m != nil {
		return m.SpanKind
	}
	return v1.Span_SPAN_KIND_UNSPECIFIED
}

// Operation contains information about an operation for a given service.
type Operation struct {
	Name                 string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SpanKind             v1.Span_SpanKind `protobuf:"varint,2,opt,name=span_kind,json=spanKind,proto3,enum=opentelemetry.proto.trace.v1.Span_SpanKind" json:"span_kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Operation) Reset()         { *m = Operation{} }
func (m *Operation) String() string { return proto.CompactTextString(m) }
func (*Operation) ProtoMessage()    {}
func (*Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{5}
}
func (m *Operation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Operation.Unmarshal(m, b)
}
func (m *Operation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Operation.Marshal(b, m, deterministic)
}
func (m *Operation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Operation.Merge(m, src)
}
func (m *Operation) XXX_Size() int {
	return xxx_messageInfo_Operation.Size(m)
}
func (m *Operation) XXX_DiscardUnknown() {
	xxx_messageInfo_Operation.DiscardUnknown(m)
}

var xxx_messageInfo_Operation proto.InternalMessageInfo

func (m *Operation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Operation) GetSpanKind() v1.Span_SpanKind {
	if m != nil {
		return m.SpanKind
	}
	return v1.Span_SPAN_KIND_UNSPECIFIED
}

// GetOperationsResponse represents the response for GetOperationsRequest.
type GetOperationsResponse struct {
	Operations           []*Operation `protobuf:"bytes,1,rep,name=operations,proto3" json:"operations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetOperationsResponse) Reset()         { *m = GetOperationsResponse{} }
func (m *GetOperationsResponse) String() string { return proto.CompactTextString(m) }
func (*GetOperationsResponse) ProtoMessage()    {}
func (*GetOperationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{6}
}
func (m *GetOperationsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetOperationsResponse.Unmarshal(m, b)
}
func (m *GetOperationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetOperationsResponse.Marshal(b, m, deterministic)
}
func (m *GetOperationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetOperationsResponse.Merge(m, src)
}
func (m *GetOperationsResponse) XXX_Size() int {
	return xxx_messageInfo_GetOperationsResponse.Size(m)
}
func (m *GetOperationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetOperationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetOperationsResponse proto.InternalMessageInfo

func (m *GetOperationsResponse) GetOperations() []*Operation {
	if m != nil {
		return m.Operations
	}
	return nil
}

type TraceQueryParams struct {
	// service_name is a filter for traces that have been generated by a specific service.
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// operation_name is a filter for traces that have been generated by a specific operation.
	OperationName string `protobuf:"bytes,2,opt,name=operation_name,json=operationName,proto3" json:"operation_name,omitempty"`
	// attributes contains a map of key-value pairs where the key is the name of the attribute
	// and the value is the string-representation of the attribute value.
	// Attributes are matched against the attributes of the resources and spans.
	// At least one span in a trace must match all specified attributes.
	Attributes map[string]string `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// start_time_min is the start of the time interval for the query. All the returned traces
	// will contain spans that have started after this time.
	StartTimeMin time.Time `protobuf:"bytes,4,opt,name=start_time_min,json=startTimeMin,proto3,stdtime" json:"start_time_min"`
	// start_time_max is the end of the time interval for the query. All the returned traces
	// will contain spans that have started before this time.
	StartTimeMax time.Time `protobuf:"bytes,5,opt,name=start_time_max,json=startTimeMax,proto3,stdtime" json:"start_time_max"`
	// min_duration is the minimum duration of the trace in nanoseconds. All the returned traces
	// will have spans that lasted alteast this long.
	MinDuration time.Duration `protobuf:"bytes,6,opt,name=min_duration,json=minDuration,proto3,stdduration" json:"min_duration"`
	// max_duration is the maximum duration of the trace in nanoseconds. All the returned traces
	// will have spans that lasted at most this long.
	MaxDuration time.Duration `protobuf:"bytes,7,opt,name=max_duration,json=maxDuration,proto3,stdduration" json:"max_duration"`
	// max_traces is the maximum number of traces to return. If the number of traces
	// matching the query is greater than this number, only the first max_traces
	// traces will be returned.
	MaxTraces            int32    `protobuf:"varint,8,opt,name=max_traces,json=maxTraces,proto3" json:"max_traces,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TraceQueryParams) Reset()         { *m = TraceQueryParams{} }
func (m *TraceQueryParams) String() string { return proto.CompactTextString(m) }
func (*TraceQueryParams) ProtoMessage()    {}
func (*TraceQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{7}
}
func (m *TraceQueryParams) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TraceQueryParams.Unmarshal(m, b)
}
func (m *TraceQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TraceQueryParams.Marshal(b, m, deterministic)
}
func (m *TraceQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraceQueryParams.Merge(m, src)
}
func (m *TraceQueryParams) XXX_Size() int {
	return xxx_messageInfo_TraceQueryParams.Size(m)
}
func (m *TraceQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TraceQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_TraceQueryParams proto.InternalMessageInfo

func (m *TraceQueryParams) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *TraceQueryParams) GetOperationName() string {
	if m != nil {
		return m.OperationName
	}
	return ""
}

func (m *TraceQueryParams) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *TraceQueryParams) GetStartTimeMin() time.Time {
	if m != nil {
		return m.StartTimeMin
	}
	return time.Time{}
}

func (m *TraceQueryParams) GetStartTimeMax() time.Time {
	if m != nil {
		return m.StartTimeMax
	}
	return time.Time{}
}

func (m *TraceQueryParams) GetMinDuration() time.Duration {
	if m != nil {
		return m.MinDuration
	}
	return 0
}

func (m *TraceQueryParams) GetMaxDuration() time.Duration {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *TraceQueryParams) GetMaxTraces() int32 {
	if m != nil {
		return m.MaxTraces
	}
	return 0
}

// FindTracesRequest represents a request to find traces.
type FindTracesRequest struct {
	Query                *TraceQueryParams `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FindTracesRequest) Reset()         { *m = FindTracesRequest{} }
func (m *FindTracesRequest) String() string { return proto.CompactTextString(m) }
func (*FindTracesRequest) ProtoMessage()    {}
func (*FindTracesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{8}
}
func (m *FindTracesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FindTracesRequest.Unmarshal(m, b)
}
func (m *FindTracesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FindTracesRequest.Marshal(b, m, deterministic)
}
func (m *FindTracesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindTracesRequest.Merge(m, src)
}
func (m *FindTracesRequest) XXX_Size() int {
	return xxx_messageInfo_FindTracesRequest.Size(m)
}
func (m *FindTracesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindTracesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindTracesRequest proto.InternalMessageInfo

func (m *FindTracesRequest) GetQuery() *TraceQueryParams {
	if m != nil {
		return m.Query
	}
	return nil
}

type FindTraceIDsResponse struct {
	TraceIds             [][]byte `protobuf:"bytes,1,rep,name=trace_ids,json=traceIds,proto3" json:"trace_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindTraceIDsResponse) Reset()         { *m = FindTraceIDsResponse{} }
func (m *FindTraceIDsResponse) String() string { return proto.CompactTextString(m) }
func (*FindTraceIDsResponse) ProtoMessage()    {}
func (*FindTraceIDsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3441c0fd9397413c, []int{9}
}
func (m *FindTraceIDsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FindTraceIDsResponse.Unmarshal(m, b)
}
func (m *FindTraceIDsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FindTraceIDsResponse.Marshal(b, m, deterministic)
}
func (m *FindTraceIDsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindTraceIDsResponse.Merge(m, src)
}
func (m *FindTraceIDsResponse) XXX_Size() int {
	return xxx_messageInfo_FindTraceIDsResponse.Size(m)
}
func (m *FindTraceIDsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindTraceIDsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindTraceIDsResponse proto.InternalMessageInfo

func (m *FindTraceIDsResponse) GetTraceIds() [][]byte {
	if m != nil {
		return m.TraceIds
	}
	return nil
}

func init() {
	proto.RegisterType((*GetTraceParams)(nil), "jaeger.storage.v2.GetTraceParams")
	proto.RegisterType((*GetTracesRequest)(nil), "jaeger.storage.v2.GetTracesRequest")
	proto.RegisterType((*GetServicesRequest)(nil), "jaeger.storage.v2.GetServicesRequest")
	proto.RegisterType((*GetServicesResponse)(nil), "jaeger.storage.v2.GetServicesResponse")
	proto.RegisterType((*GetOperationsRequest)(nil), "jaeger.storage.v2.GetOperationsRequest")
	proto.RegisterType((*Operation)(nil), "jaeger.storage.v2.Operation")
	proto.RegisterType((*GetOperationsResponse)(nil), "jaeger.storage.v2.GetOperationsResponse")
	proto.RegisterType((*TraceQueryParams)(nil), "jaeger.storage.v2.TraceQueryParams")
	proto.RegisterMapType((map[string]string)(nil), "jaeger.storage.v2.TraceQueryParams.AttributesEntry")
	proto.RegisterType((*FindTracesRequest)(nil), "jaeger.storage.v2.FindTracesRequest")
	proto.RegisterType((*FindTraceIDsResponse)(nil), "jaeger.storage.v2.FindTraceIDsResponse")
}

func init() { proto.RegisterFile("trace_storage.proto", fileDescriptor_3441c0fd9397413c) }

var fileDescriptor_3441c0fd9397413c = []byte{
	// 830 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0x9b, 0xa4, 0x89, 0x4f, 0xd2, 0xd0, 0x4e, 0x83, 0xe4, 0x9a, 0x9f, 0xa6, 0x2e, 0xa5,
	0x91, 0x90, 0x1c, 0x9a, 0x5e, 0x00, 0x05, 0x84, 0x5a, 0xf5, 0x87, 0x52, 0x51, 0xc0, 0x2d, 0x42,
	0xe2, 0xa2, 0x61, 0x1a, 0x0f, 0x91, 0x69, 0x3c, 0x76, 0xc7, 0x93, 0x28, 0xe1, 0x29, 0xe0, 0x6e,
	0x6f, 0xf7, 0x72, 0x9f, 0x60, 0x5f, 0x61, 0x9f, 0x62, 0xf7, 0x2d, 0xf6, 0x7a, 0xe5, 0x99, 0xb1,
	0xf3, 0xab, 0xfe, 0xec, 0xee, 0x4d, 0x34, 0x73, 0xfc, 0x9d, 0x6f, 0xbe, 0x73, 0xbe, 0x99, 0x13,
	0x58, 0xe5, 0x0c, 0xb7, 0x49, 0x2b, 0xe2, 0x01, 0xc3, 0x1d, 0x62, 0x87, 0x2c, 0xe0, 0x01, 0x5a,
	0xf9, 0x07, 0x93, 0x0e, 0x61, 0x76, 0x12, 0xed, 0x37, 0xcd, 0x6a, 0x27, 0xe8, 0x04, 0xe2, 0x6b,
	0x23, 0x5e, 0x49, 0xa0, 0xf9, 0x69, 0x27, 0x08, 0x3a, 0x5d, 0xd2, 0x10, 0xbb, 0xeb, 0xde, 0xdf,
	0x0d, 0xb7, 0xc7, 0x30, 0xf7, 0x02, 0xaa, 0xbe, 0xaf, 0x4f, 0x7f, 0xe7, 0x9e, 0x4f, 0x22, 0x8e,
	0xfd, 0x50, 0x01, 0xf6, 0x82, 0x90, 0x50, 0x4e, 0xba, 0xc4, 0x27, 0x9c, 0x0d, 0x25, 0xae, 0xd1,
	0x0e, 0xba, 0x5d, 0xd2, 0xe6, 0x01, 0x6b, 0x08, 0x71, 0x8d, 0xfe, 0x4e, 0x43, 0xa9, 0x24, 0xac,
	0xef, 0xb5, 0x95, 0x4a, 0xb3, 0x3e, 0x2f, 0x77, 0x32, 0x43, 0x22, 0xad, 0x67, 0x1a, 0x54, 0x4e,
	0x08, 0xbf, 0x8c, 0x43, 0xbf, 0x62, 0x86, 0xfd, 0x08, 0xad, 0x41, 0x51, 0x72, 0x7a, 0xae, 0xa1,
	0xd5, 0xb4, 0x7a, 0xd9, 0x29, 0x88, 0xfd, 0xa9, 0x8b, 0x7e, 0x00, 0x88, 0x38, 0x66, 0xbc, 0x15,
	0x8b, 0x35, 0x16, 0x6a, 0x5a, 0xbd, 0xd4, 0x34, 0x6d, 0x59, 0x89, 0x9d, 0x54, 0x62, 0x5f, 0x26,
	0x95, 0x1c, 0xe4, 0xfe, 0x7b, 0xb5, 0xae, 0x39, 0xba, 0xc8, 0x89, 0xa3, 0xe8, 0x5b, 0x28, 0x12,
	0xea, 0xca, 0xf4, 0xec, 0x03, 0xd3, 0x0b, 0x84, 0xba, 0x71, 0xcc, 0x3a, 0x83, 0xe5, 0x44, 0x6a,
	0xe4, 0x90, 0xdb, 0x1e, 0x89, 0x38, 0xfa, 0x0a, 0xf2, 0xb7, 0x3d, 0xc2, 0x86, 0x86, 0x56, 0xcb,
	0xd6, 0x4b, 0xcd, 0x0d, 0x7b, 0xc6, 0x1f, 0x7b, 0xb2, 0x3c, 0x47, 0xe2, 0xad, 0x2a, 0xa0, 0x13,
	0xc2, 0x2f, 0x64, 0xdb, 0x12, 0x3a, 0x6b, 0x07, 0x56, 0x27, 0xa2, 0x51, 0x18, 0xd0, 0x88, 0x20,
	0x13, 0x8a, 0xaa, 0xc1, 0x91, 0x38, 0x48, 0x77, 0xd2, 0xbd, 0xf5, 0x2f, 0x54, 0x4f, 0x08, 0xff,
	0x25, 0x24, 0xd2, 0xde, 0x54, 0x99, 0x01, 0x05, 0x85, 0x11, 0x5d, 0xd4, 0x9d, 0x64, 0x8b, 0x7e,
	0x04, 0x3d, 0x0a, 0x31, 0x6d, 0xdd, 0x78, 0xd4, 0x15, 0x4d, 0xac, 0x34, 0xbf, 0xb0, 0x27, 0x1c,
	0x93, 0xcd, 0xb0, 0xa5, 0x51, 0xfd, 0x1d, 0xfb, 0x22, 0xc4, 0x54, 0xfc, 0x9c, 0x79, 0xd4, 0x75,
	0x8a, 0x91, 0x5a, 0x59, 0x1e, 0xe8, 0xe9, 0xc1, 0x08, 0x41, 0x8e, 0x62, 0x3f, 0x39, 0x4d, 0xac,
	0xdf, 0xe3, 0x51, 0xbf, 0xc3, 0x87, 0x53, 0x65, 0xaa, 0xde, 0x7c, 0x07, 0x10, 0xa4, 0x51, 0x65,
	0xc3, 0xc7, 0x73, 0x6c, 0x48, 0x53, 0x9d, 0x31, 0xbc, 0xf5, 0x3c, 0x07, 0xcb, 0xc2, 0x9d, 0xdf,
	0x62, 0x57, 0xd4, 0x0d, 0xdc, 0x80, 0xb2, 0xea, 0x55, 0x6b, 0xac, 0xa2, 0x92, 0x8a, 0x9d, 0xc7,
	0x85, 0x6d, 0x41, 0x25, 0x65, 0x91, 0xa0, 0x05, 0x01, 0x5a, 0x4a, 0xa3, 0x02, 0x76, 0x01, 0x80,
	0x39, 0x67, 0xde, 0x75, 0x8f, 0x93, 0xc8, 0xc8, 0x0a, 0x71, 0xbb, 0x73, 0xc4, 0x4d, 0x4b, 0xb0,
	0xf7, 0xd3, 0xac, 0x23, 0xca, 0xd9, 0xd0, 0x19, 0xa3, 0x41, 0x3f, 0x41, 0x65, 0xf4, 0x0a, 0x5a,
	0xbe, 0x47, 0x8d, 0xdc, 0xbd, 0x57, 0xb9, 0xf8, 0xe2, 0xe5, 0x7a, 0x46, 0x5c, 0xe7, 0x72, 0xfa,
	0x1a, 0x7e, 0xf6, 0xe8, 0x34, 0x17, 0x1e, 0x18, 0xf9, 0xb7, 0xe3, 0xc2, 0x03, 0x74, 0x0c, 0x65,
	0xdf, 0xa3, 0xad, 0x64, 0xd0, 0x18, 0x8b, 0x82, 0x69, 0x6d, 0x86, 0xe9, 0x50, 0x01, 0x24, 0xd1,
	0x93, 0x98, 0xa8, 0xe4, 0x7b, 0x34, 0x09, 0x0b, 0x1e, 0x3c, 0x18, 0xf1, 0x14, 0x1e, 0xc3, 0x83,
	0x07, 0x29, 0xcf, 0x27, 0x00, 0x31, 0x8f, 0xb8, 0x5a, 0x91, 0x51, 0xac, 0x69, 0xf5, 0xbc, 0xa3,
	0xfb, 0x78, 0x20, 0x5f, 0xb0, 0xf9, 0x3d, 0x7c, 0x30, 0xd5, 0x65, 0xb4, 0x0c, 0xd9, 0x1b, 0x32,
	0x54, 0x7e, 0xc7, 0x4b, 0x54, 0x85, 0x7c, 0x1f, 0x77, 0x7b, 0x89, 0xbd, 0x72, 0xb3, 0xb7, 0xf0,
	0xb5, 0x66, 0x9d, 0xc3, 0xca, 0xb1, 0x47, 0xdd, 0xc9, 0x71, 0xf0, 0xcd, 0x68, 0x1c, 0xc4, 0x9a,
	0x37, 0x1f, 0x60, 0x75, 0x32, 0x10, 0x76, 0xa1, 0x9a, 0xf2, 0x9d, 0x1e, 0x8e, 0xee, 0xf7, 0x47,
	0xa0, 0x27, 0xe3, 0x50, 0x5e, 0xef, 0xb2, 0x53, 0x54, 0xf3, 0x30, 0x6a, 0xbe, 0xce, 0x42, 0x49,
	0x64, 0x38, 0x04, 0xbb, 0x84, 0xa1, 0x2b, 0xd0, 0xd3, 0x11, 0x85, 0x36, 0xef, 0x18, 0x46, 0x89,
	0x62, 0xb3, 0x7e, 0xf7, 0x73, 0x94, 0xe0, 0x43, 0xcc, 0xb1, 0x95, 0xf9, 0x52, 0x43, 0x57, 0x50,
	0x1a, 0x9b, 0x4f, 0x68, 0x6b, 0xfe, 0x09, 0x53, 0x53, 0xcd, 0xfc, 0xfc, 0x3e, 0x98, 0x2c, 0xd5,
	0xca, 0x20, 0x17, 0x96, 0x26, 0x5e, 0x39, 0xda, 0x9e, 0x9f, 0x3a, 0x33, 0xee, 0xcc, 0xfa, 0xfd,
	0xc0, 0xf4, 0x94, 0xbf, 0x00, 0x46, 0xd6, 0xa1, 0xcf, 0xe6, 0x64, 0xce, 0x38, 0xfb, 0xc8, 0x3e,
	0xb5, 0xa0, 0x3c, 0x6e, 0xe6, 0x03, 0xcf, 0xd8, 0xbe, 0x0b, 0x35, 0x76, 0x27, 0xac, 0x4c, 0xf3,
	0xa9, 0xa6, 0x8c, 0xff, 0x83, 0x79, 0x9c, 0x30, 0xf4, 0xbf, 0x06, 0x8b, 0x47, 0x83, 0x30, 0x60,
	0x1c, 0xed, 0xcf, 0x55, 0x9a, 0xfe, 0x73, 0x8f, 0x34, 0x4b, 0xbc, 0x60, 0x51, 0x56, 0x24, 0x42,
	0x0e, 0xde, 0x85, 0x22, 0xd1, 0x78, 0xa0, 0xff, 0x59, 0x50, 0x85, 0x5c, 0x2f, 0x0a, 0x86, 0xdd,
	0x37, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x1e, 0xd1, 0x4a, 0xd4, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TraceReaderClient is the client API for TraceReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TraceReaderClient interface {
	// GetTraces returns a stream that retrieves all traces with given IDs.
	//
	// Chunking requirements:
	// - A single TracesData chunk MUST NOT contain spans from multiple traces.
	// - Large traces MAY be split across multiple, *consecutive* TracesData chunks.
	// - Each returned TracesData object MUST NOT be empty.
	//
	// Edge cases:
	// - If no spans are found for any given trace ID, the ID is ignored.
	// - If none of the trace IDs are found in the storage, an empty response is returned.
	// - If an error is encountered, the stream returns the error and stops.
	GetTraces(ctx context.Context, in *GetTracesRequest, opts ...grpc.CallOption) (TraceReader_GetTracesClient, error)
	// GetServices returns all service names known to the backend from traces
	// within its retention period.
	GetServices(ctx context.Context, in *GetServicesRequest, opts ...grpc.CallOption) (*GetServicesResponse, error)
	// GetOperations returns all operation names for a given service
	// known to the backend from traces within its retention period.
	GetOperations(ctx context.Context, in *GetOperationsRequest, opts ...grpc.CallOption) (*GetOperationsResponse, error)
	// FindTraces returns a stream that retrieves traces matching query parameters.
	//
	// The chunking rules are the same as for GetTraces.
	//
	// If no matching traces are found, an empty stream is returned.
	// If an error is encountered, the iterator returns the error and stops.
	//
	// There's currently an implementation-dependent ambiguity whether all query filters
	// (such as multiple tags) must apply to the same span within a trace, or can be satisfied
	// by different spans.
	FindTraces(ctx context.Context, in *FindTracesRequest, opts ...grpc.CallOption) (TraceReader_FindTracesClient, error)
	// FindTraceIDs returns a stream that retrieves IDs of traces matching query parameters.
	//
	// If no matching traces are found, an empty stream is returned.
	// If an error is encountered, the stream returns the error and stops.
	//
	// This call behaves identically to FindTraces, except that it returns only the list
	// of matching trace IDs. This is useful in some contexts, such as batch jobs, where a
	// large list of trace IDs may be queried first and then the full traces are loaded
	// in batches.
	FindTraceIDs(ctx context.Context, in *FindTracesRequest, opts ...grpc.CallOption) (*FindTraceIDsResponse, error)
}

type traceReaderClient struct {
	cc *grpc.ClientConn
}

func NewTraceReaderClient(cc *grpc.ClientConn) TraceReaderClient {
	return &traceReaderClient{cc}
}

func (c *traceReaderClient) GetTraces(ctx context.Context, in *GetTracesRequest, opts ...grpc.CallOption) (TraceReader_GetTracesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TraceReader_serviceDesc.Streams[0], "/jaeger.storage.v2.TraceReader/GetTraces", opts...)
	if err != nil {
		return nil, err
	}
	x := &traceReaderGetTracesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TraceReader_GetTracesClient interface {
	Recv() (*v1.TracesData, error)
	grpc.ClientStream
}

type traceReaderGetTracesClient struct {
	grpc.ClientStream
}

func (x *traceReaderGetTracesClient) Recv() (*v1.TracesData, error) {
	m := new(v1.TracesData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *traceReaderClient) GetServices(ctx context.Context, in *GetServicesRequest, opts ...grpc.CallOption) (*GetServicesResponse, error) {
	out := new(GetServicesResponse)
	err := c.cc.Invoke(ctx, "/jaeger.storage.v2.TraceReader/GetServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traceReaderClient) GetOperations(ctx context.Context, in *GetOperationsRequest, opts ...grpc.CallOption) (*GetOperationsResponse, error) {
	out := new(GetOperationsResponse)
	err := c.cc.Invoke(ctx, "/jaeger.storage.v2.TraceReader/GetOperations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *traceReaderClient) FindTraces(ctx context.Context, in *FindTracesRequest, opts ...grpc.CallOption) (TraceReader_FindTracesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TraceReader_serviceDesc.Streams[1], "/jaeger.storage.v2.TraceReader/FindTraces", opts...)
	if err != nil {
		return nil, err
	}
	x := &traceReaderFindTracesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TraceReader_FindTracesClient interface {
	Recv() (*v1.TracesData, error)
	grpc.ClientStream
}

type traceReaderFindTracesClient struct {
	grpc.ClientStream
}

func (x *traceReaderFindTracesClient) Recv() (*v1.TracesData, error) {
	m := new(v1.TracesData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *traceReaderClient) FindTraceIDs(ctx context.Context, in *FindTracesRequest, opts ...grpc.CallOption) (*FindTraceIDsResponse, error) {
	out := new(FindTraceIDsResponse)
	err := c.cc.Invoke(ctx, "/jaeger.storage.v2.TraceReader/FindTraceIDs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TraceReaderServer is the server API for TraceReader service.
type TraceReaderServer interface {
	// GetTraces returns a stream that retrieves all traces with given IDs.
	//
	// Chunking requirements:
	// - A single TracesData chunk MUST NOT contain spans from multiple traces.
	// - Large traces MAY be split across multiple, *consecutive* TracesData chunks.
	// - Each returned TracesData object MUST NOT be empty.
	//
	// Edge cases:
	// - If no spans are found for any given trace ID, the ID is ignored.
	// - If none of the trace IDs are found in the storage, an empty response is returned.
	// - If an error is encountered, the stream returns the error and stops.
	GetTraces(*GetTracesRequest, TraceReader_GetTracesServer) error
	// GetServices returns all service names known to the backend from traces
	// within its retention period.
	GetServices(context.Context, *GetServicesRequest) (*GetServicesResponse, error)
	// GetOperations returns all operation names for a given service
	// known to the backend from traces within its retention period.
	GetOperations(context.Context, *GetOperationsRequest) (*GetOperationsResponse, error)
	// FindTraces returns a stream that retrieves traces matching query parameters.
	//
	// The chunking rules are the same as for GetTraces.
	//
	// If no matching traces are found, an empty stream is returned.
	// If an error is encountered, the iterator returns the error and stops.
	//
	// There's currently an implementation-dependent ambiguity whether all query filters
	// (such as multiple tags) must apply to the same span within a trace, or can be satisfied
	// by different spans.
	FindTraces(*FindTracesRequest, TraceReader_FindTracesServer) error
	// FindTraceIDs returns a stream that retrieves IDs of traces matching query parameters.
	//
	// If no matching traces are found, an empty stream is returned.
	// If an error is encountered, the stream returns the error and stops.
	//
	// This call behaves identically to FindTraces, except that it returns only the list
	// of matching trace IDs. This is useful in some contexts, such as batch jobs, where a
	// large list of trace IDs may be queried first and then the full traces are loaded
	// in batches.
	FindTraceIDs(context.Context, *FindTracesRequest) (*FindTraceIDsResponse, error)
}

// UnimplementedTraceReaderServer can be embedded to have forward compatible implementations.
type UnimplementedTraceReaderServer struct {
}

func (*UnimplementedTraceReaderServer) GetTraces(req *GetTracesRequest, srv TraceReader_GetTracesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTraces not implemented")
}
func (*UnimplementedTraceReaderServer) GetServices(ctx context.Context, req *GetServicesRequest) (*GetServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServices not implemented")
}
func (*UnimplementedTraceReaderServer) GetOperations(ctx context.Context, req *GetOperationsRequest) (*GetOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperations not implemented")
}
func (*UnimplementedTraceReaderServer) FindTraces(req *FindTracesRequest, srv TraceReader_FindTracesServer) error {
	return status.Errorf(codes.Unimplemented, "method FindTraces not implemented")
}
func (*UnimplementedTraceReaderServer) FindTraceIDs(ctx context.Context, req *FindTracesRequest) (*FindTraceIDsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindTraceIDs not implemented")
}

func RegisterTraceReaderServer(s *grpc.Server, srv TraceReaderServer) {
	s.RegisterService(&_TraceReader_serviceDesc, srv)
}

func _TraceReader_GetTraces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetTracesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TraceReaderServer).GetTraces(m, &traceReaderGetTracesServer{stream})
}

type TraceReader_GetTracesServer interface {
	Send(*v1.TracesData) error
	grpc.ServerStream
}

type traceReaderGetTracesServer struct {
	grpc.ServerStream
}

func (x *traceReaderGetTracesServer) Send(m *v1.TracesData) error {
	return x.ServerStream.SendMsg(m)
}

func _TraceReader_GetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraceReaderServer).GetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.storage.v2.TraceReader/GetServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraceReaderServer).GetServices(ctx, req.(*GetServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TraceReader_GetOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraceReaderServer).GetOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.storage.v2.TraceReader/GetOperations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraceReaderServer).GetOperations(ctx, req.(*GetOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TraceReader_FindTraces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FindTracesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TraceReaderServer).FindTraces(m, &traceReaderFindTracesServer{stream})
}

type TraceReader_FindTracesServer interface {
	Send(*v1.TracesData) error
	grpc.ServerStream
}

type traceReaderFindTracesServer struct {
	grpc.ServerStream
}

func (x *traceReaderFindTracesServer) Send(m *v1.TracesData) error {
	return x.ServerStream.SendMsg(m)
}

func _TraceReader_FindTraceIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindTracesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraceReaderServer).FindTraceIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.storage.v2.TraceReader/FindTraceIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraceReaderServer).FindTraceIDs(ctx, req.(*FindTracesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TraceReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.storage.v2.TraceReader",
	HandlerType: (*TraceReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServices",
			Handler:    _TraceReader_GetServices_Handler,
		},
		{
			MethodName: "GetOperations",
			Handler:    _TraceReader_GetOperations_Handler,
		},
		{
			MethodName: "FindTraceIDs",
			Handler:    _TraceReader_FindTraceIDs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTraces",
			Handler:       _TraceReader_GetTraces_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindTraces",
			Handler:       _TraceReader_FindTraces_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "trace_storage.proto",
}

// TraceWriterClient is the client API for TraceWriter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TraceWriterClient interface {
	Export(ctx context.Context, in *v11.ExportTraceServiceRequest, opts ...grpc.CallOption) (*v11.ExportTraceServiceResponse, error)
}

type traceWriterClient struct {
	cc *grpc.ClientConn
}

func NewTraceWriterClient(cc *grpc.ClientConn) TraceWriterClient {
	return &traceWriterClient{cc}
}

func (c *traceWriterClient) Export(ctx context.Context, in *v11.ExportTraceServiceRequest, opts ...grpc.CallOption) (*v11.ExportTraceServiceResponse, error) {
	out := new(v11.ExportTraceServiceResponse)
	err := c.cc.Invoke(ctx, "/jaeger.storage.v2.TraceWriter/Export", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TraceWriterServer is the server API for TraceWriter service.
type TraceWriterServer interface {
	Export(context.Context, *v11.ExportTraceServiceRequest) (*v11.ExportTraceServiceResponse, error)
}

// UnimplementedTraceWriterServer can be embedded to have forward compatible implementations.
type UnimplementedTraceWriterServer struct {
}

func (*UnimplementedTraceWriterServer) Export(ctx context.Context, req *v11.ExportTraceServiceRequest) (*v11.ExportTraceServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Export not implemented")
}

func RegisterTraceWriterServer(s *grpc.Server, srv TraceWriterServer) {
	s.RegisterService(&_TraceWriter_serviceDesc, srv)
}

func _TraceWriter_Export_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.ExportTraceServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TraceWriterServer).Export(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jaeger.storage.v2.TraceWriter/Export",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TraceWriterServer).Export(ctx, req.(*v11.ExportTraceServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TraceWriter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "jaeger.storage.v2.TraceWriter",
	HandlerType: (*TraceWriterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Export",
			Handler:    _TraceWriter_Export_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trace_storage.proto",
}
